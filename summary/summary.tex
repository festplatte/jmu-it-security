\documentclass[12pt]{article}

\usepackage{answers}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{mathrsfs}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage[english]{babel}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}

\DeclareMathOperator{\sech}{sech}
\DeclareMathOperator{\csch}{csch}

\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{definition}[2][Definition]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{solution}[2][Solution]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{problem}[2][Problem]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{question}[2][Question]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\begin{document}
	
	% --------------------------------------------------------------
	%                         Start here
	% --------------------------------------------------------------
	
	\title{IT-Security}
	\author{Michael Gabler}
	
	\maketitle
	\tableofcontents
	\newpage
	
	\section{Definitions}
	
	\textbf{C-I-A Triad}
	\begin{enumerate}
		\item \textbf{C}onfidentiality: prevents unauthorized access to private data
		\item \textbf{I}ntegrity: protects information from being modified by unauthorized parties
		\item \textbf{A}vailability: authorized parties have access to the information when needed
		\item \textbf{A}uthenticity: Being able to verify a party
		\item \textbf{A}ccountability: To guaranty that a property or action belongs to one specific entity
	\end{enumerate}
	\textbf{Secrecy} Keep data hidden from unintended receivers\\
	\textbf{Privacy} Keep data about a person secret\\
	\textbf{Anonymity} Keep identity of a communicating party secret\\
	\textbf{Authorization} Allowing another entity to perform an action (access control)\\
	\textbf{Security Threat} A potential for violation of security (interruption (a), interception (p), modification (a), fabrication (a) of information) $\rightarrow$ splits up into active and passive\\
	\textbf{Security Attack} Action that compromises the security of information\\
	\textbf{Passive Attacker} Listens to communication and tries to gain information about it\\
	\textbf{Active Attacker} Manipulates communication (replay, alter, delete messages), Brute-force\\
	\textbf{Security Mechanism} A process or device that is designed to detect, prevent or recover from a security attack\\
	\textbf{Security Service} Service to prevent security attacks by implementing one or more mechanisms\\
	\textbf{Co-prime} are two numbers $a$ and $b$ when $\gcd(a,b) = 1$
	
	\section{One Key Cryptography}
	\textbf{Kerckhoffs' principle} \textit{The enemy knows the system} $\rightarrow$ The cipher should remain secure if the adversary knows the specification of the cipher\\
	$\Rightarrow$ not respecting this principle means \textbf{security by obscurity}\\
	\textbf{Encryption Scheme} is a pair of encryption ($Enc$) and decryption ($Dec$) algorithm with $Dec_k(Enc_k(m)) = m$ for every plaintext message $m \in M$ plaintext space and key $k \in K$ key space. $Dec_k(m) = c$ generates the cipher $c \in C$ ciphertext space.\\
	\textbf{Security of an encryption scheme} The adversary should not learn any additional information about $m$ when receiving $c$
	
	\subsection{Historical ciphers}
	\paragraph{Caesar's shift cipher} $M = {A,...,Z} = {0,...,25}$ words over alphabet\\
	$K = {0,...25}$\\
	$Enc_k(m_0,...,m_n) = (k+m_0 mod 26,..., k+m_n mod 26)$\\
	$Dec_k(c_0,...,c_n) = (c_0-k mod 26,..., c_n-k mod 26)$\\
	$\Rightarrow$ can be broken by brute force attack (try every key) since $|K| = 26$
	\paragraph{Substitution cipher}
	Do not shift each letter with the same key but use a mapping table\\
	\includegraphics[width=\textwidth]{figures/substitution-cipher.JPG}\\
	$\Rightarrow$ can be broken by using statistical patterns: for example the letter E is the most frequent in the german language
	\paragraph{Vigen√®re cipher} Use a key with arbitrary length of letters. Each letter of the key defines the shift value for a plaintext letter. If the plaintext is longer than the key it must be repeated.\\
	\includegraphics[width=\textwidth]{figures/vigenere-cipher.JPG}\\
	$\Rightarrow$ when the key is repeated its possible that the same letters are encrypted with the same shift which result in the same ciphertext. If such \textbf{identical parts} are found the \textbf{length of $k$} can be computed. Now it's possible to break the cipher by applying $|k|$-times the \textbf{frequency attack} from the substitution cipher.
	
	\subsection{One-time pad}
	$K = M = C = {0,1}^t$\\
	$Enc_k(m) = k xor m$\\
	$Dec_k(m) = k xor c$\\
	$\Rightarrow$ This is perfectly secure but not practical because a key can only be used once (otherwise same ciphertext for same plaintext) and therefore must be as long as the message which is also not practical. So there's no other perfectly secret cipher.\\
	$\Rightarrow$ Other encryption schemes rely on a limitation of the adversary's power (mostly meant \underline{computational} power)
	\textbf{Computational security} A system $X$ is $(t,\epsilon)$-secure if every Turing Machine that operates in time $t$ can break it with probability at most $\epsilon$ where $\epsilon$ is negligible (close to 0).
	
	\subsection{Attacks}
	\textbf{Ciphertext-only attack} The adversary has no information about the plaintext\\
	\textbf{Known plaintext attack} The plaintext is drawn from some distribution that the adversary does not control\\
	\textbf{Chosen-plaintext attack} The adversary can choose arbitrary plaintext and receives the ciphertext from it\\
	\textbf{Chosen-ciphertext attack} The adversary gets information by receiving the decryption of chosen ciphertexts
	
	\subsection{Modern cryptography}
	\textbf{One-way functions} are functions that are poly-time computable and hard to invert. Rely on a mathematical hardness assumption.\\
	\textbf{Pseudorandom generators (PRG)} Generate bits that look random. Depens on a seed (for example system time). Can be constructed by using a one-way function. They are cryptographic if it's not % TODO finish definition\\
	\textbf{Stream cipher} cipher with an infinite stream of bits as output (for example RC4 used for WEP, WPA) $\rightarrow$ PRGs are stream ciphers\\
	\textbf{Block ciphers} are almost equal to pseudorandom permutations (PRP) (permutation is pseudorandom if it can't be distinguished from a real random permutation). Block ciphers permute a predefined amount of plaintext or data into a ciphertext of the same length. Popular block ciphers are:\\
	\begin{tabular}{|l|c|c|}
		\hline 
		& \textbf{key length} & \textbf{block length} \\ 
		\hline 
		DES (Data Encryption Standard) & 56 & 64 \\ 
		\hline 
		IDEA (International Data Encryption Algorithm) & 128 & 64 \\ 
		\hline 
		AES (Advanced Encryption Standard) & 128, 192 or 256 & 128 \\ 
		\hline 
	\end{tabular}\\
	\textbf{Padding} If a stream encrypted with a block cipher the last plaintext block needs to be padded (for example PKCS\#5: add $x$ bytes with value $x$)
	
	\subsubsection{Modes of operation}
	They describe how large amounts of plaintext can be encrypted using block ciphers.\\
	\begin{tabular}{|l|c|c|c|c|}
		\hline 
		& ECB & CBC & OFB & CTR \\ 
		\hline 
		error in $c_i$ affects & $c_i$ & $c_i$, $c_{i+1}$ & $c_i$ & $c_i$ \\ 
		\hline 
		parallel encryption & yes & no & no & yes \\ 
		\hline 
		parallel decryption & yes & yes & no & yes \\ 
		\hline 
		change 1 bit of $m_i$ & $c_i$ & all & $c_i$ & $c_i$ \\ 
		\hline 
	\end{tabular}

	\paragraph{Electronic Codebook (ECB)} $\leftarrow$ not secure\\
	\includegraphics[width=0.5\textwidth]{figures/Ecb_encryption.png}
	\includegraphics[width=0.5\textwidth]{figures/Ecb_decryption.png}\\
	$\Rightarrow$ the same plaintext block will result the same ciphertext block
	\paragraph{Cipher-Block Chaining (CBC)} .\\
	\includegraphics[width=0.5\textwidth]{figures/Cbc_encryption.png}
	\includegraphics[width=0.5\textwidth]{figures/Cbc_decryption.png}
	\paragraph{Output Feedback Mode (OFB)} .\\
	\includegraphics[width=0.5\textwidth]{figures/Ofb_encryption.png}
	\includegraphics[width=0.5\textwidth]{figures/Ofb_decryption.png}
	\paragraph{Counter Mode (CTR)} .\\
	\includegraphics[width=0.5\textwidth]{figures/Ctr_encryption.png}
	\includegraphics[width=0.5\textwidth]{figures/Ctr_decryption.png}
	
	\section{Message authentication}
	Ensure that a message is from a specified party and was not modified during transition.
	\textbf{Message authentication code (MAC) scheme} is a pair of tag ($Tag$) and verify ($Vrfy$) algorithm with $Vrfy_k(m,Tag_k(m)) = yes$ (tag is valid) for every plaintext message $m \in M$ plaintext space and key $k \in K$ key space. $Tag_k(m) = t$ generates a tag $t \in T$ set of tags. The verify algorithm just computes the tag again from the plaintext and compares the result with the given tag.\\
	$\rightarrow$ can be constructed from block ciphers (e.g. CBC-MAC) or hash functions\\
	\textbf{Replay attack} MACs do protect against the modification of the message through a third party but not against replaying an already delivered message with a valid tag again. Solution: time-stamps, sequence numbers, ...
	\textbf{Splicing attack} A CBC-MAC should be used with the message length $|m|$ as initialization vector (IV). Otherwise a splicing attack is possible:\\
	\includegraphics[width=\textwidth]{figures/splicing-attack.JPG}
	
	\subsection{Hash functions}
	Hash functions map arbitrary input to a fixed length of output. They should be collision resistant and one-way functions.(?)\\
	\textbf{Collision resistance} It's hard to find two inputs that have the same hash: $H(m) = H(m')$
	\textbf{Examples} of hash functions are MD5, SHA1, SHA2, SHA256, ...\\
	\textbf{HMAC} MAC based on a hash function: $HMAC_k(m) = H((k xor opad) || H(k xor ipad || m))$
	
	\subsection{Key distribution}
	\textbf{Key distribution center} There is an authority that all the users trust with its help it's possible to exchange session keys for direct communication. Not useful in the internet.\\
	${M}_K = Enc_{K0}(M), Tag_{K1}(Enc_{K0}(M))$ is a message $M$ that is encrypted and authenticated with key pair $K$.
	\textbf{Needham-Schroeder protocol} is a protocol for key exchange that prevents against reply and man-in-the-middle attacks (adversary can't reply the answer of the server because of the nonce, adversary can't manipulate message from Alice to Bob to change the identity who's sending the message)\\
	\includegraphics[width=\textwidth]{figures/needham-schroeder-protocol.JPG}\\
	\textbf{Peer-to-peer key distribution} can be achieved with public key cryptography
	
	\section{Public Key Cryptography}
	\paragraph{Encryption} Instead of using one key $k$, use a public key $pk$ for encryption and a private or secret key $sk$ for decryption.\\
	$\Rightarrow$ everyone can encrypt messages for the person who owns the private key because the encryption key is public
	\paragraph{Authentication} Use the private key to create a tag (also called signing a message) and the public key to validate the tag\\
	$\Rightarrow$ everyone can validate tags from the person who owns the private key. So signatures can be passed on and also be verified by a third party.
	\paragraph{Problems}
	\begin{itemize}
		\item how are the public keys exchanged?
		\item how to revoke keys?
	\end{itemize}
	
	\subsection{RSA algorithm}
	RSA is a trapdoor one-way function which can be inverted if a secret (the secret key) is known. The security relies on the hardness of the \textbf{factorization of large integers}.\\
	\textbf{Key generation} Generate large primes $p$, $q$ (1024 bits each is seen as secure $\rightarrow$ 2048 bit RSA)\\
	Compute $N=pq$ and $\varphi(N)=(p-1)(q-1)$, choose $e$ as co-prime to $\varphi(N)$, choose unique $d$ as inverse of $e \mod \varphi(N) \rightarrow ed = 1 \mod \varphi(N)$\\
	\textbf{Public key} = $(e,N)$, \textbf{private key} = $d$\\
	\textbf{Encryption} $c = m^e \mod N$\\
	\textbf{Decryption} $c^d \mod N = (m^e)^d \mod N = m$\\
	$\Rightarrow$ To be secure a (pseudo-)random padding is required so that the algorithm doesn't output the same ciphertext for the same plaintext.
	
	\subsection{Elgamal}
	Another public key cryptosystem which is based on the discrete logarithm hardness assumption.
	
	\subsection{Distribution of public keys}
	\textbf{Cerification Authority (CA)} signs certificates that hold the public key of a person and specify to which person it belongs. So everyone who has the public key of the CA and trusts it can verify the certificate.\\
	\textbf{Certificate Chain} CA certificates a person $P_1$ who can certificate another person $P_2$. A third person who trusts the CA and $P_1$ can now trust $P_2$. But \textbf{trust is not transitive}! CA must grant $P_1$ the right to certificate others (recommendation levels limit the length of the certification chain).\\
	\textbf{HTTPS/SSL} Root certificates that certificate a CA come with the browser and are build-in with recommendation level 1. So the browser trusts every certificate signed by the build-in CAs.
	
	\subsection{Diffie-Hellman key exchange}
	To encrypt the communication between two parties one key cryptography is used more often but the key is established using public key cryptography (for example HTTPS). This is because public key cryptography requires more computational power and is therefore slower. The Diffie-Hellman protocol is for exchanging new session keys for synchronous encryption. It relies on the hardness assumption of the difficulty of solving the \textbf{discrete logarithm problem (DLP)}.
	\begin{enumerate}
		\item choose prime $p$
		\item choose generator $g$ of $\mathbb{Z}_p^*$ (generator can compose every number in $\mathbb{Z}_p^* = x \mod p$ when multiplied with itself several times)
		\item Alice chooses random $x$ with $0 < x < p-2$ and calculates $h_1 = g^x \mod p$ and sends it to Bob
		\item Bob chooses random $y$ with $0 < y < p-2$ and calculates $h_2 = g^y \mod p$ and sends it to Alice
		\item the common key is $k = h_1^y \mod p = h_2^x \mod p = g^{xy} \mod p$
	\end{enumerate}
	$\Rightarrow$ because the logarithm in closed groups (discrete logarithm) is hard to compute this scheme is secure\\
	$\Rightarrow$ does not protect against man-in-the-middle attacks
	
	\section{Network Security}
	\textbf{Traditional network security model} trusted end nodes, unreliable network (e.g. internet)\\
	\textbf{Sniffing} Listening to network traffic and try to learn confidential information\\
	\textbf{Spoofing} Sending face messages pretending to be someone else\\
	\textbf{Man in the middle (MitM)} Manipulating message flow\\
	\textbf{Denial of Service} Attacking a service so that it is not available anymore
	
	\subsection{Internet protocol suite}
	Communication on the internet is redirected over routers which work on the network layer.\\
	\includegraphics[width=\textwidth]{figures/internet-protocol-suite.JPG}\\
	\begin{tabular}{|l|l|l|}
		\hline 
		\textbf{Acronym} & \textbf{Full name} & \textbf{Description} \\ 
		\hline 
		HTTP & Hypertext Transfer Protocol & Request-response protocol for communication \\ 
		\hline 
		IP & Internet Protocol & Relaying packets in/between networks \\ 
		\hline 
		IPSec & IP Security Protocol & Security layer for IP \\ 
		\hline 
		TCP & Transmission Control Protocol & Connection-oriented protocol for IP networks \\ 
		\hline
		UDP & User Datagram Protocol & Exchange messages in IP network \\ 
		\hline 
		SSL/ & Secure Sockets Layer & Adds end-to-end security at transport layer \\ 
		TSL & Transport Layer Security Protocols & \\ 
		\hline 
		SSH & Secure Shell & Cryptographic layer for command shell \\ 
		\hline 
		MAC & Media Access Control & Link Layer packet delivery to hosts \\ 
		\hline 
		LLC & Logical Link Control & Flow control and error control duties \\ 
		\hline 
		DNS & Domain name system protocol & Translates domain names to IP addresses \\ 
		\hline 
		DHCP & Dynamic Host Configuration Protocol & Dynamic assignment of host configuration \\ 
		\hline 
		ICMP & Internet Control Message Protocol & Communicate errors and operational information \\ 
		\hline 
		ARP & Address resolution protocol & Maps IP to MAC address \\ 
		\hline 
	\end{tabular} 

	\subsection{Attacks}
	\paragraph{Link layer} Describes attacks on link layer protocols\\
	\textbf{MAC flooding} Switches manage a list which MAC address is connected to which port so packets for a MAC address will only be forwarded to the known port. The attacker floods the switch with new mappings so that the list runs full. If the switch now receives a packet for a MAC address it doesn't know, it is broadcasted to all ports, so the attacker can read the traffic.\\
	$\Rightarrow$ can be prevented by port security (limit mappings per port) or control network access separately\\
	\textbf{ARP attacks} ARP is a protocol to find the MAC address of a party to the given IP address within a local network. It uses request-response architecture and mapping entries get renewed even if there's no request.\\
	$\rightarrow$ Denial-of-service and man-in-the-middle possible\\
	\includegraphics[width=0.5\textwidth]{figures/arp-dos1.JPG}
	\includegraphics[width=0.5\textwidth]{figures/arp-dos2.JPG}\\
	\includegraphics[width=0.33\textwidth]{figures/arp-mitm1.JPG}
	\includegraphics[width=0.33\textwidth]{figures/arp-mitm2.JPG}
	\includegraphics[width=0.33\textwidth]{figures/arp-mitm3.JPG}\\
	$\Rightarrow$ can be prevented by static ARP entries, certification and validation of responses, detect multiple IPs for single MAC
	
	\paragraph{Network layer} Describes attacks on network layer protocols\\
	\textbf{Ping flood} Send excessive amounts of ping requests to victim. This reduces the resources that can be used to answer other connections.\\
	$\Rightarrow$ Disallow pings completely, limits for ping requests (rate, size)\\
	\textbf{Smurf attack against ICMP} Send ping request with victim's IP as source address to broadcast address. Every network client will send a ping response to the victim.\\
	$\Rightarrow$ Disallow pings to broadcast addresses
	
	\paragraph{Transport layer} Describes attacks on transport layer protocols\\
	\textbf{SYN flood} Normal TCP flow: A:SYN $\rightarrow$ B:SYN-ACK $\rightarrow$ A:ACK. If an attacker A sends multiple SYN packets but not the ACK packets the server B keeps half-open connections. If its limit is reached new connections won't be accepted.\\
	$\Rightarrow$ can be prevented by dropping oldest half-open handshake, TCP Cookie Transaction (server and client support required), SYN cookie\\
	\textbf{TCP Session hijacking} Authentication of sessions often only during creation. After that an attacker could read the increasing sequence numbers from sent packets and reply to the server with the next higher sequence number to take over the session. The attacker has to be faster than the regular client.\\
	$\Rightarrow$ can be prevented by using SSL/TSL
	
	\paragraph{Application layer} Describes attacks on application layer protocols\\
	\textbf{DHCP starvation} Client asks for network configuration (e.g. IP address to use). The attacker can request multiple IP addresses to produce a denial of service when there's no free IP address left.\\
	\textbf{Rogue DHCP} Attacker claims all IP addresses. If new client requests one the attacker has to answer faster than the regular DHCP server and tell the client to take him as gateway to read his traffic $\rightarrow$ Man-in-the-middle\\
	$\Rightarrow$ can be prevented by monitoring DHCP traffic, port security to prevent attackers from using multiple MAC addresses
	\textbf{DNS amplification} DNS responses are up to 50 times larger than the requests. So by adding a victim's IP address as source an attacker can produce much traffic towards a victim (can be increased by using a botnet) $\rightarrow$ denial-of-service\\
	$\Rightarrow$ can be prevented by using DNSSEC or DNSCurve\\
	\textbf{WiFi deauthentication} An attacker can send a deauthentication frame (not encrypted) with the victim's MAC to the access point. So the victim gets disconnected.
	
	\subsection{Layer Security}
	\paragraph{Network Layer Security - IPSec} End-to-end encryption requires application layer security which is complicated to handle for the user (manage keys), for transport layer security the applications needs to be changed $\rightarrow$ network layer security can happen without the user noticing (e.g. VPN)\\
	\textbf{Modes of operation}
	\begin{itemize}
		\item Transport mode: Encrypts IP packet's payload, not the header. Used between hosts.
		\item Tunnel mode: Entire IP packet is encrypted and is payload of a surrounding new IP packet which can have different target and source addresses. Can be used between hosts, gateways or host-gateway
	\end{itemize}
	Authenticate over certificate chain, encrypt with synchronous connection key that needs to be exchanged.

	\paragraph{Transport Layer Security - SSL/TLS} Additional sublayer on top of TCP to encrypt payload. Protocols that run over TCP can run over SSL/TLS with a few changes (e.g. reserve extra port): HTTP $\rightarrow$ HTTPS, SMTP $\rightarrow$ SMTPS, ...\\
	Authenticate over certificate chain, encrypt over pre-exchanged synchronous connection key.
	
	\section{Authentication}
	Authentication for humans is not trivial because it's hard for them to remember long passphrases or keys. Usually secure channel is established then human authenticates itself.\\
	\textbf{Credentials} Claim for an identity + proof $\rightarrow$ username + password
	
	\subsection{Knowledge-based authentication}
	Identity verification via shared secret, e.g. password, pin, one-time password, questions \& answers
	\paragraph{Advantages} everyone can use it, cheap, fast, easy distribution, can be passed on, legal protection
	\paragraph{Disadvantages} user-dependent, usability vs. security, can be forgotten, observation possible (just watching, keyloggers), future security (computational power increases so must the password length/complexity)
	\paragraph{Attacks} Online cracking (brute-force) $\rightarrow$ use rate- and guess-limiting, offline cracking (e.g. password hash) $\rightarrow$ store passwords secure as hash with salt and pepper, hash cracking with rainbow tables: pre-computed table with hashes that get reduced and hashed again
	\paragraph{Entropy} Amount of missing information measured in bits. Human chosen passwords have less entropy than random ones.
	$$H = -\Sigma_{x \in passwords}(P(x) \log_2 P(x))$$
	Random passwords have entropy $H = \log_2 N$ where $N$ are all possible passwords.
	\paragraph{Challenge-Response} Authentication between client and server based on a shared secret which is not transmitted. Server generates challenge, client computes solution to challenge with shared secret and sends it to the server which checks it and returns its proof.
	
	\subsection{Ownership-based authentication}
	Identity verification via something you own, e.g. device, key files, hardware tokens (ID cards)
	\paragraph{Advantages} more entropy due to key storage, easy to revoke, depends on physical security, can be passed on like physical key
	\paragraph{Disadvantages} high costs due to hardware, easy to loose/steal, communication between hardware and reader could be eavesdropped
	
	\subsection{Inherence-based authentication}
	Identity verification via behavioral or physiological characteristics (biometrics)
	\paragraph{Advantages} can't be stolen or forgotten, easy to use
	\paragraph{Disadvantages} can't be changed when compromised, could change or become unavailable (through accidents), can't be passed on for temporary access of thirds, same login data for different services
	\paragraph{Selection of biometric parameters} universal, unique, permanent, measurable, performance, acceptable (by the population), circumvention (hard to fool the system)
	\paragraph{Examples} fingerprints (can be gained from surfaces, pictures), facial recognition (3D to prevent unlocking with photos), voice recognition, signature, DNA, iris scan, typing patterns, gait, mouse movement
	
	\subsection{Multi-factor authentication}
	Identity verification via combining multiple authentication methods $\rightarrow$ usability security trade-off\\
	For example combine passwords with face recognition, sms codes, email links, etc.
	
	\section{Software security}
	\textbf{Runtime attacks} are attacks that happen during the runtime of a program\\
	\textbf{Remote code execution} means that arbitrary code from the attacker is executed on the target system\\
	\textbf{Privilege escalation} increases the abilities that a program has to manipulate the system (e.g. normal user to admin)\\
	\textbf{Architectures} common system architectures are x86-32, x64-64, ARM\\
	\textbf{Most important registers in x86-32 architecture}\\
	\begin{tabular}{|l|l|}
		\hline 
		\textbf{Register} & \textbf{Description} \\ 
		\hline 
		EAX, EBX & general purpose registers \\ 
		ECX, EDX &  \\ 
		ESI, EDI &  \\ 
		EBP &  \\ 
		\hline 
		ESP & Stack pointer (general purpose) \\ 
		\hline 
		EIP & Instruction pointer \\ 
		\hline 
		EFLAGS & Flags for arithmetic operations (e.g. carry flag, overflow flag, ...) \\ 
		\hline 
	\end{tabular}\\
	\textbf{Endianness} defines the order of bytes in the memory
	\begin{itemize}
		\item \textbf{Big-endian format} most significant bytes first: 0xAF11 $\rightarrow$ 0x0000AF11 (32 bit) (used in IPv4, TCP, ...)
		\item \textbf{Little-endian format} least significant bytes first: 0xAF11 $\rightarrow$ 0x11AF0000 (32 bit) (used for x86-32)
	\end{itemize}
	\textbf{Memory layout}\\
	\includegraphics[width=0.2\textwidth]{figures/memory-layout.png}\\
	Stack consists out of multiple frames, one frame per function call which holds the function arguments, the return address (saved instruction pointer), saved base pointer of the calling function and local variables of the function.\\
	Manipulation of the program flow can be achieved by a buffer overflow. When the attacker enters data that is stored in a data structure without bound checking and the entered data exceeds the reserved space it will overwrite data on the stack, e.g. the return address.
	
	\subsection{Code Injection}
	The attacker tries to inject arbitrary code (often the execution of a shell) into the program flow. Not often used due to data execution prevention (DEP) which prevents code execution from writable memory.\\
	\textbf{Format string bug} Including user input in the format string of e.g. \textit{printf} is dangerous because if there are placeholder like\textit{ \%s} used and no arguments are given, this will print values from the stack. If there are more placeholders without arguments than values on the stack the program will crash $\rightarrow$ denial-of-service
	
	% TODO continue with lecture 10
	
	\subsection{Code reuse} The attacker tries to manipulate the program flow so that existing code is executed in a different order.
	
	\end{document}
